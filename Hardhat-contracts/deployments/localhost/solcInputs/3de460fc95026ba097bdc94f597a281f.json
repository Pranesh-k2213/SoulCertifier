{
  "language": "Solidity",
  "sources": {
    "contracts/SoulCertifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\n\r\nerror NotCreaterOfToken();\r\nerror ContractDoesNotAllowApprovals();\r\nerror ContractDoesNotAllowTransfer();\r\nerror NoTokenAvilable();\r\n\r\ncontract SoulCertifier is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    // Mapping from token ID to account balances\r\n    mapping(uint256 => mapping(address => bool)) private _balances;\r\n\r\n    // Mapping to token Id to creaters (certificate providers)\r\n    mapping(uint256 => address) private _createdBy;\r\n\r\n    // To store latest token Id\r\n    uint256 private tokenId;\r\n\r\n    // To store uri\r\n    string private _uri;\r\n\r\n    event BunchCreated(address indexed by, uint256 indexed id, address[] to);\r\n    event TokenBurned(address indexed account, address indexed by, uint256 indexed id);\r\n\r\n    modifier callerIsCreater(address creater, uint256 id) {\r\n        if (creater != _createdBy[id]) {\r\n            revert NotCreaterOfToken();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(string memory newUri) {\r\n        _uri = newUri;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(ERC165, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    // function supportedInterfaceReturn() public pure returns (bytes4) {\r\n    //     return type(IERC1155).interfaceId;\r\n    // }\r\n\r\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\r\n        return _balances[id][account] ? 1 : 0;\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    function setApprovalForAll(address, bool) public pure override {\r\n        revert ContractDoesNotAllowApprovals();\r\n    }\r\n\r\n    function isApprovedForAll(address, address) public pure override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public pure override {\r\n        revert ContractDoesNotAllowTransfer();\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public pure override {\r\n        revert ContractDoesNotAllowTransfer();\r\n    }\r\n\r\n    // Function to provide certificates without specifying the tokenID\r\n    // It creates new tokenId\r\n    function createBunch(address[] memory accounts) public returns (uint256) {\r\n        address creater = msg.sender;\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            if (accounts[i] != address(0)) {\r\n                _balances[tokenId][accounts[i]] = true;\r\n                //emit TransferSingle(creater, address(0), accounts[i], tokenId, 1);\r\n            }\r\n        }\r\n        _createdBy[tokenId] = creater;\r\n        emit BunchCreated(creater, tokenId, accounts);\r\n        tokenId += 1;\r\n        return tokenId - 1;\r\n    }\r\n\r\n    // Function call with token ID to add new accounts to already exsisting certificate token\r\n    function createBunchWithId(address[] memory accounts, uint256 id)\r\n        public\r\n        callerIsCreater(msg.sender, id)\r\n    {\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            if (accounts[i] != address(0)) {\r\n                _balances[id][accounts[i]] = true;\r\n                //emit TransferSingle(msg.sender, address(0), accounts[i], id, 1);\r\n            }\r\n        }\r\n        emit BunchCreated(msg.sender, id, accounts);\r\n        return;\r\n    }\r\n\r\n    function burnToken(address account, uint256 id) public callerIsCreater(msg.sender, id) {\r\n        if (!_balances[id][account]) {\r\n            revert NoTokenAvilable();\r\n        }\r\n        _balances[id][account] = false;\r\n        emit TokenBurned(account, msg.sender, id);\r\n        //emit TransferSingle(msg.sender, account, address(0), id, 1);\r\n    }\r\n\r\n    // Getters\r\n    function getNextTokenId() public view returns (uint256) {\r\n        return tokenId;\r\n    }\r\n\r\n    function getCreatedBy(uint256 id) public view returns (address) {\r\n        return _createdBy[id];\r\n    }\r\n\r\n    function uri(uint256) public view override returns (string memory) {\r\n        return _uri;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}